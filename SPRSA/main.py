#!/Users/11834/.conda/envs/Pytorch_GPU/python.exe
# -*- coding: UTF-8 -*-
'''=================================================
@Project -> File    ：FWorks -> SPRSA
@IDE    ：PyCharm
@Date   ：2020/12/6 10:56
=================================================='''
import numpy as np
from torch.autograd import Variable
import torch, os
from Util.feature_extraction import PSSMPSFMPSSPRSAGetWindowPadheadfoot
from BiLSTM_SE_Net import LSTMMergeSENet
from Util.processing_pssm_msaTopsfm import Processing_PSSM_MSAToPSFM
from Util.WriteFile import appendWrite

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
from Util.feature_generation import FeaturesGeneration


def tester(fa_path, result_dir):
    save_model = "./save_model/"
    model = LSTMMergeSENet().to(device)
    saved_model = save_model + 'epoch_' + str(50)
    model.load_state_dict(torch.load(saved_model))
    optimizer = torch.optim.Adam(model.parameters())
    saved_model = save_model + 'epoch_' + str(50) + 'opt'
    optimizer.load_state_dict(torch.load(saved_model))

    model.eval()
    with torch.no_grad():
        Data = PSSMPSFMPSSPRSAGetWindowPadheadfoot(fa_path, result_dir)
        fea, fea_reverse, protein = Data.getIthSampleFea()
        fea_pssm, fea_psfm, fea_pss, fea_jpsfm = torch.FloatTensor(fea[0]), torch.FloatTensor(
            fea[1]), torch.FloatTensor(fea[2]), torch.FloatTensor(fea[3])
        fea_pssm, fea_psfm, fea_pss, fea_jpsfm = torch.unsqueeze(fea_pssm, 0), torch.unsqueeze(fea_psfm,
                                                                                               0), torch.unsqueeze(
            fea_pss, 0), torch.unsqueeze(fea_jpsfm, 0)
        fea_pssm, fea_psfm, fea_pss, fea_jpsfm = Variable(fea_pssm.float()).to(device), Variable(fea_psfm.float()).to(
            device), Variable(fea_pss.float()).to(device), Variable(fea_jpsfm.float()).to(device)

        fea_pssm_rev, fea_psfm_rev, fea_pss_rev, fea_jpsfm_rev = torch.FloatTensor(fea_reverse[0]), torch.FloatTensor(
            fea_reverse[1]), torch.FloatTensor(fea_reverse[2]), torch.FloatTensor(fea_reverse[3])
        fea_pssm_rev, fea_psfm_rev, fea_pss_rev, fea_jpsfm_rev = torch.unsqueeze(fea_pssm_rev, 0), torch.unsqueeze(
            fea_psfm_rev, 0), torch.unsqueeze(fea_pss_rev, 0), torch.unsqueeze(fea_jpsfm_rev, 0)
        fea_pssm_rev, fea_psfm_rev, fea_pss_rev, fea_jpsfm_rev = Variable(fea_pssm_rev.float()).to(device), Variable(
            fea_psfm_rev.float()).to(device), Variable(fea_pss_rev.float()).to(device), Variable(
            fea_jpsfm_rev.float()).to(device)
        predict00 = model(fea_pssm, fea_psfm, fea_pss, fea_jpsfm)
        predict01 = model(fea_pssm_rev, fea_psfm_rev, fea_pss_rev, fea_jpsfm_rev)
        predict = (predict00[4] + predict01[4]) / 2

        predict = predict.cuda().data.cpu().numpy()
        seq = np.loadtxt(fa_path, dtype=str)[1]
        pro_length = len(seq)
        filename = protein + ".rsa"
        ASAValue = Processing_PSSM_MSAToPSFM()
        file_path = os.path.join(result_dir, filename)
        appendWrite(file_path, '{:>4}\n\n'.format("# SPRSA VFORMAT (SPRSA V1.0)"))
        appendWrite(file_path, '{:>1}  {:>1}  {:>4}  {:>4}\t\n'.format("No", "AA", "RSA", "ASA"))
        for i in range(pro_length):
            index, residue, RSA = i + 1, seq[i], predict[i, 0]
            SA = ASAValue.MAXASAValue(seq[i]) * predict[i, 0]
            appendWrite(file_path, '{:>4}  {:>1}  {:>.3f}  {:>.3f}\t\n'.format(index, residue, RSA, SA))
        appendWrite(file_path, '{}'.format("END"))


def main():
    print("Initialize CUDA", device)

    import argparse
    parser = argparse.ArgumentParser(description="SPRSA Predict Protein Solvent Accessibility")

    parser.add_argument("-p", "--fa_path", required=True, type=str, help="sequence path")
    parser.add_argument("-o", "--result_path", required=True, type=str, help="result path")
    args = parser.parse_args()
    
    features_generation = FeaturesGeneration(args.fa_path, args.result_path)
    print("PSSM and PSS are being generated ")
    features_generation.PSSM_PSS_generation()
    print("PSFM are being generated")
    features_generation.PSFM_generation()
    print("PRSA are being generated")
    features_generation.Threading_based_PRSA()
    print("RSA are being generated by SPRSA")
    tester(args.fa_path, args.result_path)


if __name__ == '__main__':
    main()

